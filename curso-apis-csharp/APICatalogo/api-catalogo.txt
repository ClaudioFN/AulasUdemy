Aulas 49 até 52 (04-08):
Serialização JSON alterada na classe Program.cs e incluindo na linha do código 
builder.Services.AddControllers();
esse item:
.AddJsonOptions(options => options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);
-- 
Otimização da API usando AsNoTracking para limitação de cache de rastreio armazenado e Take ou Where para filtros e limitar a quantidade 
de registros trazidos para a funcionalidade.
--
Uso de Try-Catch para tratamento de erros
--
Visão do Postman
--
--
Aulas 54 até 59 (05-08):
54 => Esclarecimento sobre definições de rotas para evitar duplicatas
--
55 => [HttpGet("/primeiro")] => a barra (/) faz com que a definição inserida em Route seja ignorada e se use essa nova definição.
   => [HttpGet("{id}/{primeiro}")] => passagem de 2 parâmetros.
   => conseguimos empilhar definições de rotas ([HttpGet]) nos endpoints.
--
56 => restrições de rota para ter um valor mínimo = [HttpGet("{id:int:min(1)}", Name = "ObterProduto")] => esse min indica o valor mínimo.
   => [HttpGet("{valor:alpha:length(5)}")] = alpha para valores alfa numéricos e length para um tamanho mínimo.
--
57 => Retornos de métodos: Tipo Específico (como tipos primitivos); IActionResult (para retornos ActionResult); ActionResult<T> (para retorno de um ActionResult com / ou tipo específico de T).
--
58 => Métodos Sincronos e Assíncronos = método Get2 da ProdutosController como exemplo.
--
59 => Model Binding serve para mapear dados de uma requisição HTTP para os parâmetros de uma de um Controlador.
   => query strings - valor é enviado na URL = ?nome=Suco&ativo=true
   => Formulário pelos métodos POST e PUT
   => BindingRequired = obriga o parâmetro a ser obrigatório.
   => BindingNever = para não colocar ele como parte dos endpoints
----
60 (06-08):
60 = FromService => Permite injetar as dependências diretamente no método Action do Controlador que requer a dependência.
--
61 até 64 (08/08): 
61 = criação de validações direto no campo - [StringLength(80, ErrorMessage = "O nome deve ter no máximo {1} caracteres!", MinimumLength = 5)]
--
62 = criação de validações personalizadas.
--
63 = usando uma interface (IValidatableObject na classe Produto) para implementar validações.
--
64 = criação de sessões no appsettings.json para incluir dados novos para tratar novos detalhes.
----
65 até 66 (09-08):
65 = como ler o arquivo appsettings.json | var valor1 = builder.Configuration["chave1"];
--
66 = conceitos sobre middleware
----
67 até 72(10-08):
67 => UseExceptionHandler = middleware de tratamento de exceções para pegar exceções não tratadas, voltando com erro 500.
--
68 => tratativas de filtros para autorizar, gerar exception, logo e cache de maneira personalizada. Antes ou depois de método Action. Inserido no método Action / controlador / globalmente.
--
69 => aplicação dos filtros. Criando registros de log dos métodos Action. BEM UTIL.
--
70 => log com diferentes níveis (Critical, Debug, Error, Information, None, Trace, Warning) usando ILogger na classe que se quer logar.
--
71 => log customizado que será gerado em um arquivo texto.
   - criou a pasta Logging
   - criou as 3 classes CustomerLogger.cs, CustomLoggerProvider.cs, CustomLoggerProviderConfiguration.cs
   - CustomLoggerProviderConfiguration = LogLevel (nível do log); EventId (id do log)
   - CustomLoggerProvider = implenta ILoggerProvider para logs personalizados.
   - CustomerLogger = define os métodos para uso do log implementando a ILogger.
   - mexer com a classe Program.cs para adiocionar o logger.
--
72 => otimização de código usando de exemp. CategoriasController mas serve para o ProdutosController.
   - Alterando a parte de tratamento de exceções (código catch). Usando IExceptionFilter para capturar exceções durante a execução do controlador.
   - Removendo o acoplamento do DbContext na classe. Usando o padrão Repository.
---- 
73 até 75 (11/08):
73 = explicação do que vem nos próximos vídeos.
--
74 = Definição de Repository
--
75 = Iniciando a criação do repository (apenas apresentando os futuros códigos)
----
76 até 79 (12/08):
76 = Criando pasta para repositories (Repositories); criando interface para categorias (ICategoriaRepository); criando classe que implementa a interface (CategoriaRepository).
--
77 = Ajustando a classe do controller Categoria (CategoriaController).
--
78 = Efetuando os testes pós alterações.
--
79 = Explicação do que os códigos a serem implementados irão fazer (dessa vez usando IQueryble).
----
80 (14/08):
80 = Criação das classes IProdutoRepository (interface) e ProdutoRepository (classe concreta)
----
81 ate (16/08):
81 = Completando a classe ProdutosController.cs como a nova formatação de uso de dados.
--
82 = teste das alterações para Produto.
--
83 = Apresentação de Padrão de Projeto Repositório Genérico
--
84 = criação do repositório genérico e apresentação do principio ISP. (IRepository)
--
85 = Criando a classe genérica (Repository) que herda da interface genérica (IRepository) e implementa os métodos especificados
--
86 = Alterando controllers para uso dos itens genéricos
----
==============================================================PENDENTE DE COMMIT PARA DIA 23 A PARTIR DAQUI = feito em 22/08
87 ate 91 (18/08):
87 = Alterando as classes de Controller (Produto e Categoria).
--
88 = Testando as alterações no Swagger.
--
89 = Apresentação do padrão Unit of Work.
   => Os repositórios são responsáveis por realizar operações de leitura e escrita no BD, mas não executam o SaveChanges. Unit of Work é quem gerencia as transações e chama o SaveChanges. Unit of Work inicia, confirma e reverte as alterações. Tudo passa por ele.
--
90 = Implementação do padrão Unit of Work (interface IUnitOfWork.cs)
--
91 = Completando a implementação do Unit Of Work (classe concreta UnitOfWork.cs)
----
92 ate 94 (20/08):
92 = Implementando as trocas do Repository
--
93 = Ajustando os Controllers
--
94 = Testes dos endpoints
----
==============================================================PENDENTE DE COMMIT PARA DIA 30 A PARTIR DAQUI = feito em 23/08
95 ate 100 (22/08): 
--
95 = Apresentação do fluxo de aulas.
--
96 = Apresentação do Data Transfer Object - DTO => Contêiner de dados usado para transportar dados entre diferentes partes / camadas de uma aplicação que define como os dados serão enviados pela rede. É parecido com ViewModel (que representa dados na camada de apresentação). Usa Mapper.
--
97 = Implementando na CategoriaController o DTO.
--
98 = Mapping de CategoriaDTO
--
99 = Realizando os ajustes para a CategoriaController.
--
100 = Apresentando o AutoMapper => Mapeamento entre objetos que representam as entidades e os objetos que representam os DTOs filtrando as propriedades que desejamos expor.
----
==============================================================PENDENTE DE COMMIT PARA DIA 30 A PARTIR DAQUI = feito em 24/08
101 ate 106 (24/08): 
--
101 = Implementando o Mapper com criação de classe (ProdutoDTOMappingProfile) e alteração do controller Produto.
--
102 = Continuação das alterações da aula 101.
--
103 = Testes após implementar.
--
104 = Apresentação do HttpPatch.
--
105 = Implementação do HttpPatch.
--
106 = Texto para ajustar uma lógica na validação presente na classe Controller do Produto, no método Patch.
-----
==============================================================PENDENTE DE COMMIT PARA DIA 30 A PARTIR DAQUI
107 ate 109 (25/08):
--
107 = Apresentação de primeiro conjunto de ferramentas alternativas ao AutoMapper e aplicação de uma delas.
--
108 = Continuação e aplicação de outra ferramenta alternativa.
--
109 = Introdução a Paginação de grandes quantidade de dados e interação de código (sem usar o projeto Catalogo).
---
110 ate 111 (26/08):
--
110 = Paginação simples com criação da classe PaginacaoParameters.cs (para os parâmetros) e adaptação em Produto (IProdutoRepository e ProdutoRepository) e alteração da classe controller.
--
111 = Explicação da próxima melhoria de paginação.
----
112 ate 115 (27/08):
--
112 = Implementando a paginação aprimorada criando nova classe PageList, alterando o IProdutoRepository e ProdutoRepository e ajustando o Controller do Produto.
--
113 = Roteirizando a paginação no Categoria.
--
114 = Implementando a paginação na categoria.
--
115 = Filtro de dados (conceitualização / roteiro).
----
116(03/09):
--
116 = Implementando a paginação e filtro por preço para Produtos
----
117 e 118(04/09):
--
117 = Implementando o Pagination na Categoria, criando a classe nova CategoriasFiltroNome.cs, alterando ICategoriaInterface.cs para ter novo método, a CategoriaRepository.cs para ter o novo método e o CategoriasController.cs para ter o novo endpoint.
--
118 = Explicação sobre programação assíncrona.
----
119 (05/09):
--
119 = Mostrando a programação assíncrona
----
120 ate 125(06/09):
--
120 = Migração de código para assíncrono
--
121 = Migração de código para assíncrono
--
122 = Migração de código para assíncrono
--
123 = Mexendo na Paginação usando biblioteca externa (X.PagedList.Mvc.Core)
--
124 = Completando a implementação assíncrona com IPagedList.
--
125 = Apresentando o que é o Autenticação e Autorização para a API.
----
126 ate 128(06/09):
--
126 = Introdutório ao assunto de JWT 
----
127 ate(07/09):
--
127 = Implementando parte do assunto de configuração de código para autenticação. Tem outros comandos na aula.
    = prompt de comando: cd <PASTA DO PROJETO ATE CHEGAR NA RAIZ DELE COM O SLN NA PASTA>
    = comando: dotnet user-jwts create
    = copiar Token gerado para usar o Bearer via Postman
--
128 = Explicação da migração a apresentação de comandos a serem usados.
----
==============================================================PENDENTE DE COMMIT PARA DIA 12 A PARTIR DAQUI = FEITO
129 (08/09):
--
129 = Alterando a classe AppDbContext.cs para uso do IdentityDbContext e incluindo na classe Program.cs
    = abrir o CMD 
    = dotnet ef - comando para confirmar que tem o pacote instalado
    = dotnet tool install --global dotnet-ef - instalar o pacote de migrations
    = dotnet ef migrations add CriaTabelasIdentity --verbose - cria a migration (so funciona na pasta dentro da SLN)
    = dotnet ef database update --verbose - implementa as modificações no bd
----
130 ate 131 (09/09):
--
130 = Alterações no fluxo da classe program.cs, do appsettings.json e no resultados
--
131 = Alteração de criação de nova classe ApplicationUser.cs, alteração da AppDbContext para apontar para a nova classe e ajuste pontual de Program.cs de Identity para o ApplicationUser.
    = dotnet ef migrations add AjusteApplicationUser - cria migração para os novos itens
    = dotnet ef database update
----
132 (10/09):
--
132 = Criação das classes para serem usados na aplicação: Response.cs, RegisterModel.cs,LoginModel.s e TokenModel.cs
--
133 = Explicações para os próximos passos.
----
134 ate (12/09):
--
134 = Implementando nova Interface ITokenservice e nova classe TokenService (apenas primeiro método).
--
135 = Implementando o método GenerateRefreshToken da classe TokenService.cs.
--
136 = Implementando o método GetPrincipalFromExpiredToken da classe Tokenservice.cs.
--
137 = Criar o controller AuthController e definir os endpoints de login, register, refreshToken e revoke.
--
138 = Criação dos endpoints (aqui apenas o primeiro endpoint de Login).
----
139 ate (13/09):
--
139 = Implementação do endpoint Register.
--
140 = Implementando o endpoint RefreshToken.
--
141 = Implementando o endpoint Revoke.
--
142 = Começo de testes do JWT implementado como nova inclusão na classe Program.cs.
--
143 = Usando a palavra Bearer antes do token, incluir o token gerado no login e assim conseguir acessar os endpoints protegidos
--
144 = Explicações sobre Role.
--
145 = Implementação do endpoint para Role.
==============================================================PENDENTE DE COMMIT PARA DIA 19 A PARTIR DAQUI
----
146 ate 148 (15/09):
--
146 = Explicação e projeto alterado na AuthController.cs para novo endpoint de adicionar Role.
--
147 = Implementação na parte de roles para a classe Programa.cs e o ajuste na classe AuthController.cs
--
148 = Novas aplicações de roles em classes alteradas.
-----
149 ate 158(19/09):
--
149 = 
--
150 = 
--
151 = 
--
152 = 
--
153 = CORS implementado para um site específico após ajuste na classe Program.cs.
--
154 = Explicações de opções CORS para permitir uso por outras origens.
--
155 = Habilitando outras formas de uso do CORS por endpoint alterando a classe Program.cs e o controller CategoriasController.cs. 
--
156 = Testes das alterações da aula 155. 
--
157 = Limitação de taxa (RateLimiting) para evitar sobrecargas, evitar DDO e reduzir custo por uso de recursos.
--
158 = Algoritmos de Rate Limiting.
----
159 ate 163(20/09):
--
159 = Aplicando RateLimit por código alterando a classe Program.cs e CategoriaController.cs.
--
160 = Continuação da aplicação do RateLimit alterando as classes já citadas.
--
161 = Novo código para definição global do RateLimit.
--
162 = Usando o appsettings.json para obter os valores que vão ser usado no RateLimit criando pasta RateOptions, classe MyRateLimitOptions, alterando a classe Program.cs e o appsettings.json.
--
163 = Detalhando motivos e definições de como acontece o versionamento de uma API.
    = Major => Grandes Mudanças.
    = Minor => Alterações que ainda são compatíveis com versões anteriores.
    = Patch => Correções.
----
164 ate 169(21/09):
--
164 = Abordagens de versionamento de API.
    = Querystring => https://api.exe.com/resource?version=1
    = URI => https://api.exe.com/v1/resource
    = Headers => X-API-Version: 1
    = Media Type => Accept: application/vnd.exe.v1+json
Pacotes para versionamento funcionar: ASP.VERSIONING.MVC.APIEXPLORER e ASP.VERSIONING.HTTP
--
165 = Apresentando o versionamento por QueryString e por URI.
--
166 = Implementando versionamento Query String.
--
167 = Implementando versionamento por URI (mais direto pois só temos que clicar em Excute para pegar a versão mas ele vai pelo default 1.0).
--
168 = Definição e implementação do MapToVersion onde dentro de 1 controller conseguimos acesso a diferentes métodos que responderiam a diferentes versões de acordo com a chamada.
--
169 = Explicação sobre o .NET 9.0 em que a implementação do Swagger virou decisão do desenvolvedor.
----
170 ate 174():
--
170 = Swagger e o pacote Swashbuckle.AspNetCore
--
171 = Ajuste simples no Program.cs para tratar de link para detalhes do Swagger (dono, site, licença)
--
172 = Instrução de como habilitar os comentários
--
173 = Implementando nos endpoints o texto de comentário
--
174 = Formas de retorno, firmando um tipo de retorno, inibindo warnings.
----
175 ate 180(24/09):
--
175 = Usando ApiConventions para definir nos retornos valores defaults gerais para códigos de retorno.
--
176 = Alterando o arquivo do projeto para incluir nova tag que faz uma varredura no código em busca de itens não declarados para códigos de retorno.
--
177 = Conceitos sobre Testes.
--
178 = Iniciando implementações sobre testes. Criação do Projeto ApiCatalogoxUnitTests
--
179 = Criação de classes de teste.
--
180 = Implementando e realizando os testes implementados.
----
181 ate 182(30/09):
--
181 = Testes Unitários para Post
--
182 = Testes Unitários para Put
----
183 ate 184 (01/10):
--
183 = Testes Unitários para Delete
--
184 = Explicando a Clean Arquiteture (com criação de vários projetos internos a API que terão seus pontos específicos)
----
185 ate 192(08/10):
--
185 = Criando o novo Solution (Catalogo), criando os projetos dela e realizando a parametrização das dependências.
--
186 = Criação das pastas para cada Projeto.
-- 
187 = só mostrou o projeto já pronto...
-- 
188 = só mostrou os detalhes pós projeto pronto...
--
189 = Explicações de funcionamento de diferentes formas de cache e vantagens / desvantagens.
-- 
190 = MemoryCache usado no IMemoryCache (Microsoft.Extensions.Caching.Memory)
    => Set = armazenar valor no cache
    => TryGetValue = tentar obter valor do cache usando uma chave.
    => GetOrCreate = obter valor de cache pela chave.
    => GetOrCreateAsync = assíncrono do GetOrCreate
    => Remove = remove um item do cache pela chave
    => Cear() = remover todas as chaves
    => MemoryCacheEntryOption = configurar o cache
--
191 = Roteiro de implementação
--
192 = Implementando o cache do Get para CategoriasController.cs e Program.cs alterados
----
193 ate 193(09/10):
--
193 = GET com ID com cache
----
194 ate 196(10/10):
--
194 = POST com cache.
--
195 = PUT com cache.
--
196 = DELETE com cache.
--
197 = Altera código do cache para melhorar a legibilidade e implementação.
--
198 = Continuação da implementação da melhoria.
--
199 = 