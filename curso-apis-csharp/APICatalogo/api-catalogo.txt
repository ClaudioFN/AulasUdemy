Aulas 49 até 52 (04-08):
Serialização JSON alterada na classe Program.cs e incluindo na linha do código 
builder.Services.AddControllers();
esse item:
.AddJsonOptions(options => options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles);
-- 
Otimização da API usando AsNoTracking para limitação de cache de rastreio armazenado e Take ou Where para filtros e limitar a quantidade 
de registros trazidos para a funcionalidade.
--
Uso de Try-Catch para tratamento de erros
--
Visão do Postman
--
--
Aulas 54 até 59 (05-08):
54 => Esclarecimento sobre definições de rotas para evitar duplicatas
--
55 => [HttpGet("/primeiro")] => a barra (/) faz com que a definição inserida em Route seja ignorada e se use essa nova definição.
   => [HttpGet("{id}/{primeiro}")] => passagem de 2 parâmetros.
   => conseguimos empilhar definições de rotas ([HttpGet]) nos endpoints.
--
56 => restrições de rota para ter um valor mínimo = [HttpGet("{id:int:min(1)}", Name = "ObterProduto")] => esse min indica o valor mínimo.
   => [HttpGet("{valor:alpha:length(5)}")] = alpha para valores alfa numéricos e length para um tamanho mínimo.
--
57 => Retornos de métodos: Tipo Específico (como tipos primitivos); IActionResult (para retornos ActionResult); ActionResult<T> (para retorno de um ActionResult com / ou tipo específico de T).
--
58 => Métodos Sincronos e Assíncronos = método Get2 da ProdutosController como exemplo.
--
59 => Model Binding serve para mapear dados de uma requisição HTTP para os parâmetros de uma de um Controlador.
   => query strings - valor é enviado na URL = ?nome=Suco&ativo=true
   => Formulário pelos métodos POST e PUT
   => BindingRequired = obriga o parâmetro a ser obrigatório.
   => BindingNever = para não colocar ele como parte dos endpoints
----
60 (06-08):
60 = FromService => Permite injetar as dependências diretamente no método Action do Controlador que requer a dependência.
--
61 até 64 (08/08): 
61 = criação de validações direto no campo - [StringLength(80, ErrorMessage = "O nome deve ter no máximo {1} caracteres!", MinimumLength = 5)]
--
62 = criação de validações personalizadas.
--
63 = usando uma interface (IValidatableObject na classe Produto) para implementar validações.
--
64 = criação de sessões no appsettings.json para incluir dados novos para tratar novos detalhes.
----
65 até 66 (09-08):
65 = como ler o arquivo appsettings.json | var valor1 = builder.Configuration["chave1"];
--
66 = conceitos sobre middleware
----
67 até 72(10-08):
67 => UseExceptionHandler = middleware de tratamento de exceções para pegar exceções não tratadas, voltando com erro 500.
--
68 => tratativas de filtros para autorizar, gerar exception, logo e cache de maneira personalizada. Antes ou depois de método Action. Inserido no método Action / controlador / globalmente.
--
69 => aplicação dos filtros. Criando registros de log dos métodos Action. BEM UTIL.
--
70 => log com diferentes níveis (Critical, Debug, Error, Information, None, Trace, Warning) usando ILogger na classe que se quer logar.
--
71 => log customizado que será gerado em um arquivo texto.
   - criou a pasta Logging
   - criou as 3 classes CustomerLogger.cs, CustomLoggerProvider.cs, CustomLoggerProviderConfiguration.cs
   - CustomLoggerProviderConfiguration = LogLevel (nível do log); EventId (id do log)
   - CustomLoggerProvider = implenta ILoggerProvider para logs personalizados.
   - CustomerLogger = define os métodos para uso do log implementando a ILogger.
   - mexer com a classe Program.cs para adiocionar o logger.
--
72 => otimização de código usando de exemp. CategoriasController mas serve para o ProdutosController.
   - Alterando a parte de tratamento de exceções (código catch). Usando IExceptionFilter para capturar exceções durante a execução do controlador.
   - Removendo o acoplamento do DbContext na classe. Usando o padrão Repository.
---- 
73 até 75 (11/08):
73 = explicação do que vem nos próximos vídeos.
--
74 = Definição de Repository
--
75 = Iniciando a criação do repository (apenas apresentando os futuros códigos)
----
76 até 79 (12/08):
76 = Criando pasta para repositories (Repositories); criando interface para categorias (ICategoriaRepository); criando classe que implementa a interface (CategoriaRepository).
--
77 = Ajustando a classe do controller Categoria (CategoriaController).
--
78 = Efetuando os testes pós alterações.
--
79 = Explicação do que os códigos a serem implementados irão fazer (dessa vez usando IQueryble).
----
80 (14/08):
80 = Criação das classes IProdutoRepository (interface) e ProdutoRepository (classe concreta)
----
81 ate (16/08):
81 = Completando a classe ProdutosController.cs como a nova formatação de uso de dados.
--
82 = teste das alterações para Produto.
--
83 = Apresentação de Padrão de Projeto Repositório Genérico
--
84 = criação do repositório genérico e apresentação do principio ISP. (IRepository)
--
85 = Criando a classe genérica (Repository) que herda da interface genérica (IRepository) e implementa os métodos especificados
--
86 = Alterando controllers para uso dos itens genéricos
----
==============================================================PENDENTE DE COMMIT PARA DIA 23 A PARTIR DAQUI = feito em 22/08
87 ate 91 (18/08):
87 = Alterando as classes de Controller (Produto e Categoria).
--
88 = Testando as alterações no Swagger.
--
89 = Apresentação do padrão Unit of Work.
   => Os repositórios são responsáveis por realizar operações de leitura e escrita no BD, mas não executam o SaveChanges. Unit of Work é quem gerencia as transações e chama o SaveChanges. Unit of Work inicia, confirma e reverte as alterações. Tudo passa por ele.
--
90 = Implementação do padrão Unit of Work (interface IUnitOfWork.cs)
--
91 = Completando a implementação do Unit Of Work (classe concreta UnitOfWork.cs)
----
92 ate 94 (20/08):
92 = Implementando as trocas do Repository
--
93 = Ajustando os Controllers
--
94 = Testes dos endpoints
----
==============================================================PENDENTE DE COMMIT PARA DIA 30 A PARTIR DAQUI
95 ate 100 (22/08): 
--
95 = Apresentação do fluxo de aulas.
--
96 = Apresentação do Data Transfer Object - DTO => Contêiner de dados usado para transportar dados entre diferentes partes / camadas de uma aplicação que define como os dados serão enviados pela rede. É parecido com ViewModel (que representa dados na camada de apresentação). Usa Mapper.
--
97 = Implementando na CategoriaController o DTO.
--
98 = Mapping de CategoriaDTO
--
99 = Realizando os ajustes para a CategoriaController.
--
100 = Apresentando o AutoMapper => Mapeamento entre objetos que representam as entidades e os objetos que representam os DTOs filtrando as propriedades que desejamos expor.
--
101 = 